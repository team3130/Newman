// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.supportingClasses;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj2.command.CommandScheduler;
import frc.robot.commands.Chassis.presets.GoToHumanPlayerStation;
import frc.robot.subsystems.Chassis;
import frc.robot.supportingClasses.Auton.AutonManager;

import java.util.function.Supplier;

/**
 * A command to generate and follow a given trajectory using Auton Manager methods.
 * Abstract because a specific class should be made that overrides the constructor in order to actually be used,
 *  see {@link GoToHumanPlayerStation} for an example
 */
public abstract class AutomaticallyGoToALocation extends CommandBase {

  /**
   * A thread that gets used to generate the auton command in case the generation takes too long it doesn't hang the thread
   */
  private final Thread thread;

  /**
   * If this has been the first hit of {@link #execute()} with a non-null {@link #autonCommand} to run initialize
   */
  private boolean firstHit = true;

  /**
   * The command that should get ran off of our generated path
   */
  protected CommandBase autonCommand;

  /**
   * Creates a new object for automatically going to a location based off a passed in runnable.
   * Gives {@link #thread} a lambda to generate a path to the closest place to place a game element.
   * Kinda a hack, but we don't need to call {@link CommandScheduler#registerComposedCommands(Command...)} because:
   * {@link #autonCommand} only requires {@link Chassis}.
   * any given runnable should update the {@link #autonCommand} field.
   *
   * @param chassis The subsystem used by this command.
   * @param generator for the {@link #thread} to run. Should be similar to {@link AutonManager#makeCmdToGoToPlace(Pose2d)}
   */
  public AutomaticallyGoToALocation(Chassis chassis, Supplier<CommandBase> generator) {
    // Use addRequirements() here to declare subsystem dependencies.
    addRequirements(chassis);

    // passes in a lambda which is the equivalent of a method reference so this doesn't need to get reset as it's  \
    // not ran until start is called off the thread
    thread = new Thread(() -> autonCommand = generator.get());
  }

  /**
   * Called once on the first run of the command being scheduled.
   * <p>
   * Resets mutable fields in case the object of this command has ran multiple times.
   */
  @Override
  public void initialize() {
    // we haven't run initialize on the command yet and the command is null because we still need to generate it
    firstHit = true;
    autonCommand = null;

    // start the thread to generate the path
    thread.start();
  }

  /**
   * Called periodically by the scheduler while **this** is scheduled.
   * If {@link #autonCommand} has been generated by the thread then initialize it and then run execute.
   * Runs until {@link #isFinished()} returns true.
   */
  @Override
  public void execute() {
    if (autonCommand != null) {
      // if it is the first hit we want to run initialize
      if (firstHit) {
          autonCommand.initialize();
          firstHit = false;
      } else {
        autonCommand.execute();
      }
    }
  }

  /**
   * Determines if the command is done running or not.
   * @return whether the command is finished doing its task. In this case it is true if the auton
   *    commands isFinished is done.
   */
  @Override
  public boolean isFinished() {
    if (autonCommand != null) {
      return autonCommand.isFinished();
    }
    return false;
  }

  /**
   * Called when the scheduler ends the auton command.
   * If the thread wasn't done when this was called, then this will interrupt it.
   * @param interrupted whether the command was interrupted/canceled. will be !{@link #isFinished()}
   */
  @Override
  public void end(boolean interrupted) {
    if (autonCommand != null) {
      autonCommand.end(interrupted);
    }
    else {
      thread.interrupt();
    }
  }
}
